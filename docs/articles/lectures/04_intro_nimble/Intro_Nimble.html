<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 4</title>
    <meta charset="utf-8" />
    <meta name="author" content="   Spring 2025" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="FANR8370.css" type="text/css" />
    <link rel="stylesheet" href="FANR8370-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Week 4
]
.subtitle[
## Introduction of Bayesian analysis using Nimble
]
.author[
### <br/><br/><br/>Spring 2025
]

---




## Readings

&gt; KÃ©ry &amp; Schaub 38-40; 58-64


---
class: inverse, middle, center

# From custom MCMC to BUGS

---
## The BUGS language

#### **B**ayesian **A**nalysis **U**sing **G**ibbs **S**ampling  

--
#### Language/program invented in the 1990's by epidemiologists in Cambridge  

--
#### Later became WinBUGS  

- First customizable MCMC software  
&lt;/br&gt;

--
- Revolutionized the use of Bayesian methods in applied statistics

---
## The BUGS language

#### Since the development of WinBUGS, other Bayesian software programs have been developed:

- OpenBugs

- [JAGS](https://sourceforge.net/projects/mcmc-jags/files/)

- [Nimble](https://r-nimble.org/)

- [Stan](https://mc-stan.org/)


--
#### For the remainder of the course, we will fit models using Nimble  

- Uses BUGS language and R (easy to learn, lots of online documentation)  

- Out-performs WinBUGS  

- Available for all operating systems

- Highly customizable

---
## The BUGS language

#### Last week, we learned how to:  

--
- Define a likelihood and priors
&lt;/br&gt;

- Write a custom MCMC sampler to produce samples from the joint posterior distribution  


--
### Given a statistical model and user-specified prior distributions, Nimble does these steps for you! 

--
- Possible to fit arbitrarily complex models `\(^1\)`  
&lt;/br&gt;

--
- "Frees the modeler in you"  


???

`\(^1\)` remember, just because you *can* fit it doesn't mean it will return robust inferences. As we have already discussed, complex models often suffer from lack of identifiability and poor sampling of the joint posterior distribution. But, if you can write out a valid statistical model, Nimble can create a sampler and draw samples from the joint posterior distribution

---
## Running Nimble from R

### Uses the `nimble` package

--
- Write model in `R` script using the `nimbleCode()` function
&lt;/br&gt;

- Send the model to nimble along with initial values and data using `nimbleModel()`
&lt;/br&gt;

- Build the MCMC automatically, compile the model and run it
&lt;/br&gt;

- Model output brought back in to `R` for diagnostics/analysis/visualization  

---
## The BUGS language

### Very similar to `R` (but slight differences)  

- Limited ability to vectorize operations  
&lt;/br&gt;

- Order of code less important (doesn't read top to bottom like `R`)

### If you can write your model on the whiteboard, you can write it in Nimble

- Stochastic relationships represented by `~`

- Deterministic relationships represented by `&lt;-`

- Since this is likelihood, uses the `d` part of distributions (e.g. dnorm, dpois, dgamma, etc.)

---
## The BUGS language

### Linear regression model
&lt;br/&gt;
&lt;br/&gt;

`$$\LARGE y_i = \alpha + \beta \times x_i + \epsilon_i$$`
&lt;/br&gt;

`$$\LARGE \epsilon_i \sim Normal(0, \tau)$$`

---
## The BUGS language

### Linear regression model

&lt;br/&gt;
&lt;br/&gt;

`$$\LARGE y_i = \underbrace{\alpha + \beta \times x_i}_{Deterministic} + \underbrace{\epsilon_i}_{Stochastic}$$`


???

Remember that `\(\tau = \frac{1}{\sigma^2}\)`

---
## The BUGS language

### Linear regression model
&lt;br/&gt;
&lt;br/&gt;

`$$\underbrace{\LARGE \mu_i = \alpha + \beta \times x_i}_{Deterministic}$$`
&lt;/br&gt;

`$$\underbrace{\LARGE y_i \sim Normal(\mu_i, \tau)}_{Stochastic}$$`
&lt;/br&gt;

--

Remember that these equations define the *likelihood* of our data given values of `\(\alpha\)`, `\(\beta\)`, and `\(\tau\)`


---
## The BUGS language

### Linear regression model

To specify a fully Bayesian model, we also need to define the priors:
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;

--


`$$\LARGE [\alpha] \sim Normal(\alpha|0, 0.001)$$`
&lt;/br&gt;

`$$\LARGE [\beta] \sim Normal(\alpha|0, 0.001)$$`
&lt;/br&gt;

`$$\LARGE [\tau] \sim Gamma(\tau|0.01, 0.01)$$`
&lt;/br&gt;

---
## The BUGS language

### Linear regression model 


``` r
library(nimble)

seedmod &lt;- nimbleCode({
  ## Priors
    alpha ~ dnorm(0, 0.001) #mean, precision
    beta ~ dnorm(0, 0.001)
    tau ~ dgamma(.001,.001) # Precision
    sigma &lt;- 1/sqrt(tau)      # Calculate sd from precision
    
  ## Likelihood
    for(i in 1:N){
      mu[i] &lt;- alpha + beta * x[i]
      y[i] ~ dnorm(mu[i], tau)
    }
}) 
```

---
## Preparing the data


``` r
## Read simulated data frame
dat &lt;- readRDS("data/sim_seed_counts.rds")

## Store data for as a named list. 
#Only 'data' if stochastic
nimdat &lt;- list(y = dat$y)

#constants are for KNOWN values not from distributions
nimconsts &lt;- list(x = dat$visits.c, N = nrow(dat))

## Create function that returns random initial values
niminits &lt;- function(){list(alpha = runif(1, 200, 300), 
                              beta = runif(1, 25, 75), 
                              tau = runif(1))}

## Store which parameters we want to monitor
params &lt;- c("alpha", "beta", "tau", "sigma")
```

---
## Run the model (One step method)


``` r
 ## Run the model
nimfit &lt;- nimbleMCMC(code = seedmod,
                     data = nimdat,
                     constants = nimconsts,
                     inits = niminits(),
                     monitors = params,
                     thin = 1,
                     niter = 10000,
                     nburnin = 2500,
                     nchains = 3,
                     samplesAsCodaMCMC = TRUE
                      )
```



---
## Diagnostics
 

``` r
str(nimfit)
```

```
## List of 3
##  $ chain1: 'mcmc' num [1:7500, 1:4] 251 251 251 252 251 ...
##   ..- attr(*, "dimnames")=List of 2
##   .. ..$ : NULL
##   .. ..$ : chr [1:4] "alpha" "beta" "sigma" "tau"
##   ..- attr(*, "mcpar")= num [1:3] 1 7500 1
##  $ chain2: 'mcmc' num [1:7500, 1:4] 252 252 251 252 251 ...
##   ..- attr(*, "dimnames")=List of 2
##   .. ..$ : NULL
##   .. ..$ : chr [1:4] "alpha" "beta" "sigma" "tau"
##   ..- attr(*, "mcpar")= num [1:3] 1 7500 1
##  $ chain3: 'mcmc' num [1:7500, 1:4] 251 252 251 251 252 ...
##   ..- attr(*, "dimnames")=List of 2
##   .. ..$ : NULL
##   .. ..$ : chr [1:4] "alpha" "beta" "sigma" "tau"
##   ..- attr(*, "mcpar")= num [1:3] 1 7500 1
##  - attr(*, "class")= chr "mcmc.list"
```
 
---
## Diagnostics
 

``` r
library(coda)
plot(nimfit)
```

&lt;img src="Intro_Nimble_files/figure-html/unnamed-chunk-6-1.png" width="504" style="display: block; margin: auto;" /&gt;

---
## Structure of the output
 

``` r
class(nimfit)
```

```
## [1] "mcmc.list"
```

``` r
names(nimfit)
```

```
## [1] "chain1" "chain2" "chain3"
```
---
## Structure of the output

``` r
summary(nimfit)
```

```
## 
## Iterations = 1:7500
## Thinning interval = 1 
## Number of chains = 3 
## Sample size per chain = 7500 
## 
## 1. Empirical mean and standard deviation for each variable,
##    plus standard error of the mean:
## 
##           Mean      SD Naive SE Time-series SE
## alpha 251.2742 0.56649 0.003777       0.003783
## beta   49.0844 0.56555 0.003770       0.003773
## sigma   7.4437 0.40205 0.002680       0.002710
## tau     0.0182 0.00195 0.000013       0.000013
## 
## 2. Quantiles for each variable:
## 
##           2.5%      25%      50%      75%    97.5%
## alpha 250.1683 250.8946 251.2745 251.6581 252.3916
## beta   47.9719  48.7021  49.0833  49.4626  50.2143
## sigma   6.7048   7.1623   7.4247   7.7034   8.2708
## tau     0.0146   0.0169   0.0181   0.0195   0.0222
```
---
## Saving model output


``` r
saveRDS(nimfit, "output/regression_out.rds")
```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"slideNumberFormat": "%current%"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
