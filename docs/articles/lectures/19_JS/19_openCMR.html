<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Lecture 19</title>
    <meta charset="utf-8" />
    <meta name="author" content="   Spring 2025" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="FANR8370.css" type="text/css" />
    <link rel="stylesheet" href="FANR8370-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Lecture 19
]
.subtitle[
## Open Population Mark Recapture
]
.author[
### <br/><br/><br/>Spring 2025
]

---



## Readings

&gt; 


&gt; 

---
## Closed Capture-mark-recapture

#### Key to closed CMR is that because individuals do not enter or leave the population, we assume any 0 in the capture history is non-detection `\(\large (1-p)\)`

- in simplest model, easy to translate capture history into probabilistic statements based only on `\(p\)`:

.pull-left[
##### Individual 1: `\(\large 101101\)`  
##### Individual 2: `\(\large 011001\)`  
]

.pull-right[
#### `\(\large p(1-p)pp(1-p)p\)`  
#### `\(\large (1-p)pp(1-p)(1-p)p\)`
]

---
## Closed CMR models

#### In all closed CMR models, `\(\large N\)` is unknown

`$$\Large z_i \sim Bernoulli(\psi)$$`


`$$\Large y_{ik} \sim Bernoulli(z_ip)$$`


`$$\Large \psi \sim beta(1,1)$$`

`$$\Large p \sim beta(1,1)$$`


`$$\Large N = \sum_{i=1}^M z_i$$`

---
## Open Capture-mark-recapture

#### In open populations, we **cannot** assume any 0 in the capture history is non-detection.

Consider the following capture history 

`$$\large 101$$`


  + In a closed model, `\(\large p(1-p)p\)`  
  
  &lt;br/&gt;
  
  + In an open model:  `\(\large (p_1*\psi_1)*((1-p_2)*\psi_2 + (1-\psi_2))*(p_3*\psi_3)\)`  

--

&lt;br/&gt;

If we want to model `\(\large \psi\)` and `\(\large p\)` as changing over time, we will need a *robust design* framework.

---
## Robust Design

You have seen the robust design before, we just didn't call it anything fancy. 


&lt;img src="figs/rd.jpg" width="75%" style="display: block; margin: auto;" /&gt;

&lt;br/&gt;

There is no disadvantage to using a robust design other than the cost of sampling, and most modern studies use this framework. 


---
## Robust Design

CJS models were first used in the late 60's/early 70's to look at survival across time. The robust design didn't appear until the 80s.


If observations only happen once per primary period, CJS models cannot not be modified for heterogeneity or permanent trap response
among individuals. Remember the assumptions of the original CJS models:

  + Every animal has the same chance of capture, p
  
  + Every animal has same probability of surviving `\(\large \phi\)`


&lt;br/&gt;

Closed CJS models are robust to this un-modeled variation; Open model are *NOT*

--

In his original papers, the likelihood was estimated in steps, by first estimating each primary period as a closed population model and then separately estimating the likelihood of moving from one time period to the next. 


We no longer estimate the likelihood in this exact way, but we have 40+ years of technology and research on our side :) 


---
## Assumptions of the Open C-R Models

+ Tagged animals are a random sample of the population of interest

&lt;br/&gt;

+ Numbers of releases are known

&lt;br/&gt;

+ Tagging is accurate, no tag loss, no misread tags, no data entry errors.

&lt;br/&gt;

+ The fate of individual animals and the fates of animals in differing cohorts are independent.



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false,
  "ratio": "16:9",
  "slideNumberFormat": "%current%"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
